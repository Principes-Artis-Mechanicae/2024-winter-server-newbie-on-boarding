# 점프_투_자바_3장

정수

- long형은 접미사 ‘L’ 혹은 ‘l’을 붙여야 함

실수

- float형은 접미사 ‘F’ 혹은 ‘f’을 붙여야 함

boolean 자료형이 있음

char a = 13; 은 아스키 코드로 받아들임

문자열

- String a = "Happy Java"; (리터럴 표기 방식)
- String a = new String("Happy Java");
- 같은 의미 하지만 살짝 다름
- 두 번째는 새로운 객체를 만들었음.

원시 자료형

- int, long, double, float, boolean, char
- new로 값 생성 x 리터럴 표기 방식만 사용 가능
- String은 리터럴 가능하나, 원시 자료형 x

문자열 내장 메서드

- a.equals(b)
    - a와 b의 문자열이 같은지
    - true, false 리턴
    - ==은 같은 객체인지
- a.indexOf(”문자열”)
    - 문자열로 시작되는 인덱스를 리턴
- a.contains(”문자열”)
    - 문자열이 포함되어 있는지
    - true, false 리턴
- a.charAt(”숫자”)
    - 숫자 인덱스의 문자를 리턴
- a.replaceAll("앞", "뒤")
    - 앞 문자열을 뒤 문자열로 변경
- a.substring(앞, 뒤)
    - 앞 인덱스부터 뒤 인덱스까지 뽑아냄
    - 뒤 인덱스의 문자는 포함 x
- a.toUpperCase()
    - 대문자로
- a.toLowerCase()
    - 소문자로
- a.split("구분자")
    - 구분자로 나누어 문자열 리턴

문자열 포매팅

- String.format(”~%d~, 4”)
    - 문자열을 리턴하는 메서드
- %s를 쓰면 자동으로 다 문자열로 받기 때문에 신경쓸 필요가 없음.
- System.out.printf(”~%d~, 4”)을 쓰면 System.out.println(String.format(”~%d~, 4”))을 쓰는 효과
    - 문자열을 출력하는 메서드

StringBuffer

- append(”~”)를 사용해 문자를 계속 추가 가능
- toString()을 통해 String으로 변경 가능
- insert(인덱스, "~")로 문자를 넣을 수 있음
- String 자료형의 substring 사용가능
- StrigBuffer()는 메모리 사용량도 많고 속도도 느림
    
    → 문자열을 추가하거나 변경하는 작업이 많으면 StringBuffer를, 적으면 String을 사용하는 것이 유리하다.
    
- StringBuilder는 StringBuffer와 거의 동일 성능이 더 우수함.

배열

- String[] weeks = {"월", "화", "수", "목", "금", "토", "일"}
- String[] weeks = **new** **String**[7]
- String[] weeks =  **new** **String**[] → 컴파일 오류
- length를 사용해 배열의 길이 활용가능

리스트

- ArrayList
    - add (인덱스 지정 가능)
    - get(인덱스)
    - size
    - contains (T/F 리턴)
    - remove(”객체”) (삭제 후 T/F 리턴)
    - remove(인덱스) (삭제 후 항목을 리턴)
    - arrayList 뒤 <자료형>을 사용해 그 자료형만 배열에 들어가도록 할 수 있음 → 제네릭스 (접근할 때 형변환 필요 x, 오류 방지 가능)
    - asList을 이용해 기존의 배열로 새로운 리스트를 만들 수 있음
        - ArrayList<String> 새로운 리스트 = **new** **ArrayList**<>(Arrays.asList(기존 배열))
        - ArrayList<String> 새로운 리스트 = **new** **ArrayList**<>(Arrays.asList(항목 여러개 나열))
    - join(”구분자”,리스트 or 배열)을 이용해 각 요소에 구분자를 넣어 하나의 문자열로 만들 수 있음
    - sort(정렬기준)
        - 오름차순(순방향) 정렬 - Comparator.naturalOrder()
        - 내림차순(역방향) 정렬 - Comparator.reverseOrder()
        

맵

- 한 쌍의 key와 value를 갖는 자료형
- Hashmap
    - put(”key”,”value”)
    - get(”key”) (”value” 리턴) (해당하는 value가 없다면 null 리턴)
    - getOrDefault("key", "value") (”value” 리턴) (해당하는 value가 없다면 default 리턴)
    - containsKey("key") (T/F리턴)
    - remove(”key”) (”value” 리턴)
    - size()
    - keySet() (집합 자료형 리턴, 리스트로 바꾸어 사용할 수도 있음)
    
    - LinkedHashMap : 입력된 순서대로 데이터를 저장
    - TreeMap : 입력된 key의 오름차순으로 데이터를 저장
    - 리스트는 순서가 중요, 맵은 순서 의존 x
    

집합

- 중복 x, 순서 x
- Hashset
    - a.retainAll(b)  (a와 b의 교집합 생성)
    - a.addAll(b) (a와 b의 합집합 생성)
    - a.removeAll(b) (a에서 b로의 차집합 생성)
    - add
    - addAll(Arrays.asList(…))
    - remove
- TreeSet : 값을 오름차순으로 정렬해 저장
- LinkedHashSet : 값을 입력한 순서대로 정렬

상수 집합

- enum
    - values() (배열 리턴)
    
    - 코드가 명확해짐
    - 잘못된 값으로 인한 오류 예방

형 변환

- Integer.parseInt(a) (String a를 Intenger로)
- Intenger a를 String으로
    - “” + a
    - String.valueOf(a)
    - Integer.toString(a)
    - Double.parseDouble(a) (소수점 포함할 때)
    - Float.parseFloat(a) (소수점 포함할 때)
- 캐스팅
    - Like 실수 앞에 (int)를 붙여 강제로 정수로 만드는 것
    - 실수 문자열을 정수로 바꾸려 하면 오류

final

- 자료형을 고정시킴
- list는 값을 더하거나 빼는 것 가능 → List.of()로 작성하면 수정 불가